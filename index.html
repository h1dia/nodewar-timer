<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êã†ÁÇπÊà¶„Åè„Çì</title>
    <style>
        :root {
            --bg-color: #f0f0f0; --card-bg: #ffffff; --text-main: #222222;
            --text-sub: #888888; --card-border: #dddddd; --finished-bg: #e8e8e8;
            --finished-opacity: 0.7; --status-bg: rgba(0, 0, 0, 0.05);
            --status-color: #666; --warning-color: #ff5252; --warning-bg: rgba(255, 82, 82, 0.12);
            --delay-badge-bg: #444444; --delay-text: #ffffff;
            --font-mono: "JetBrains Mono", "Fira Code", "Input", "Menlo", "Consolas", monospace;
        }
        [data-theme="dark"] {
            --bg-color: #050505; --card-bg: #121212; --text-main: #ffffff;
            --text-sub: #444444; --card-border: #2a2a2a; --finished-bg: #1a1a1a;
            --status-bg: rgba(255, 255, 255, 0.05);
            --delay-badge-bg: #333333;
        }

        body {
            background-color: var(--bg-color); color: var(--text-main); margin: 0;
            font-family: var(--font-mono); font-weight: 800; transition: background-color 0.4s ease;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding: 40px 20px; box-sizing: border-box;
        }

        .content-wrapper { width: 100%; max-width: 400px; display: flex; flex-direction: column; align-items: center; }
        header { width: 100%; padding-bottom: 30px; text-align: center; }
        .clock-container { display: flex; align-items: center; justify-content: center; gap: 15px; }
        
        #current-time { font-size: 2.8rem; font-weight: 900; line-height: 1; letter-spacing: -0.02em; }
        .clock-label { font-size: 0.85rem; color: var(--text-sub); margin-bottom: 8px; letter-spacing: 0.2em; }

        #delay-display {
            font-size: 1.1rem; background: var(--delay-badge-bg);
            padding: 5px 12px; border-radius: 20px; color: var(--delay-text);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2); white-space: nowrap;
        }

        #timer-container { display: flex; flex-direction: column; gap: 20px; width: 100%; }
        
        .timer-card {
            background: var(--card-bg); padding: 35px 20px; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); text-align: center;
            border: 1px solid var(--card-border); width: 100%; box-sizing: border-box;
            transition: opacity 0.6s ease, transform 0.6s ease, max-height 0.6s ease;
            max-height: 500px; overflow: hidden;
        }

        .timer-card.hidden { opacity: 0; max-height: 0; margin: 0; padding: 0; border: none; pointer-events: none; }
        .timer-card.finished { background: var(--finished-bg); opacity: var(--finished-opacity); transform: scale(0.95); }

        .display { font-size: 4rem; font-weight: 900; margin-bottom: 5px; line-height: 1; letter-spacing: -0.05em; font-variant-numeric: tabular-nums; }
        .label { font-size: 1.15rem; font-weight: 800; letter-spacing: 0.05em; margin: 8px 0 0 0; }

        .theme-toggle {
            position: fixed; top: 20px; right: 20px; width: 45px; height: 45px;
            cursor: pointer; background: var(--card-bg); color: var(--text-main);
            border: 1px solid var(--card-border); border-radius: 50%;
            display: flex; justify-content: center; align-items: center; z-index: 110;
        }

        .bottom-badge {
            position: fixed; font-size: 0.85rem; font-weight: 900;
            padding: 10px 24px; border-radius: 25px; left: 50%; transform: translateX(-50%) translateY(20px);
            transition: all 0.5s ease; opacity: 0; pointer-events: none; z-index: 90;
            display: flex; gap: 10px; align-items: center;
        }
        .bottom-badge.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        #warning-area { bottom: 65px; color: var(--warning-color); background: var(--warning-bg); border: 1px solid rgba(255, 82, 82, 0.3); }
        #status-area { bottom: 15px; color: var(--status-color); background: var(--status-bg); border: 1px solid var(--card-border); }
        .status-error { color: var(--warning-color) !important; border-color: var(--warning-color) !important; }
        
        #update-countdown { opacity: 0.6; font-size: 0.75rem; border-left: 1px solid var(--status-color); padding-left: 10px; }
    </style>
</head>
<body>

    <button class="theme-toggle" id="theme-btn" onclick="toggleTheme()">‚òÄÔ∏è</button>

    <div class="content-wrapper">
        <header>
            <div class="clock-label">ÁèæÂú®ÊôÇÂàª</div>
            <div class="clock-container">
                <div id="current-time">--:--:--</div>
                <div id="delay-display">+0s</div>
            </div>
        </header>
        <div id="timer-container"></div>
    </div>

    <div id="warning-area" class="bottom-badge">‚ö†Ô∏è Ë®≠ÂÆöÊôÇÂàª„ÅØÂè§„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô</div>
    <div id="status-area" class="bottom-badge show">
        <span id="status-text">INITIALIZING...</span>
        <span id="update-countdown">NEXT: --S</span>
    </div>

    <script>
        const CONFIG = {
            SHEET_ID: '16A_C49u3ld7n0hwqJgg503riWGBhl5UkzLT0yesYLeQ',
            API_KEY: 'AIzaSyCStsG2mbAtAruv-WN_d8hVWd0n-7QAUKc',
            RANGE: '„Ç∑„Éº„Éà1!A1:B20',
            CHECK_RANGE: '„Ç∑„Éº„Éà1!A2:B2',
            BASE_HOUR: 21,
            POLL_INTERVAL: 15000 // 15ÁßíÈñìÈöî„Å´Ë®≠ÂÆö
        };

        let state = { 
            timerData: [], 
            serverOffset: 0, 
            lastCheckData: "", 
            delaySeconds: 0,
            nextUpdateTimestamp: 0 
        };

        const updateStatus = (text, isError = false) => {
            const el = document.getElementById('status-area');
            const txtEl = document.getElementById('status-text');
            if (!el || !txtEl) return;
            txtEl.textContent = text.toUpperCase();
            el.classList.add('show');
            el.classList.toggle('status-error', isError);
        };

        async function fetchSheetData() {
            updateStatus('syncing...');
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${encodeURIComponent(CONFIG.RANGE)}?key=${CONFIG.API_KEY}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data.values) return;

                const a2Val = data.values[1]?.[0];
                document.getElementById('warning-area').classList.toggle('show', !!(a2Val && a2Val.trim()));

                state.delaySeconds = parseInt(data.values[0]?.[1], 10) || 0;
                document.getElementById('delay-display').textContent = `+${state.delaySeconds}s`;

                const now = new Date(Date.now() + state.serverOffset);
                let processed = [];

                const startTarget = getTargetTime(CONFIG.BASE_HOUR, 0);
                if (startTarget > now) {
                    processed.push({ label: "ÈñãÂßã„Åæ„Åß", targetDate: startTarget, type: "start", isFinished: false });
                }

                data.values.slice(3).forEach(row => {
                    const minute = parseInt(row[1], 10);
                    if (isNaN(minute)) return;
                    const target = getTargetTime(CONFIG.BASE_HOUR, minute + 1);
                    processed.push({ label: row[0]?.trim() || "", targetDate: target, type: "normal", isFinished: target <= now });
                });

                renderTimers(processed);
                updateStatus('updated');
            } catch (e) { 
                console.error("Fetch Error:", e);
                updateStatus('api error', true);
            } finally {
                setTimeout(() => {
                    const el = document.getElementById('status-area');
                    if (el && !el.classList.contains('status-error')) updateStatus('waiting');
                }, 2000);
            }
        }

        function getTargetTime(hour, minute) {
            const t = new Date(Date.now() + state.serverOffset);
            t.setHours(hour, minute, 0, 0);
            t.setSeconds(t.getSeconds() + state.delaySeconds);
            return t;
        }

        function renderTimers(data) {
            data.sort((a, b) => (a.isFinished !== b.isFinished) ? (a.isFinished ? 1 : -1) : (a.targetDate - b.targetDate));
            const container = document.getElementById('timer-container');
            container.innerHTML = '';
            
            state.timerData = data.map((item, i) => {
                const id = `timer-${i}`;
                const card = document.createElement('div');
                card.id = `card-${id}`;
                card.className = `timer-card ${item.isFinished ? 'finished' : ''}`;
                card.innerHTML = `<div id="${id}" class="display">--:--:--</div><p class="label">${item.label}</p>`;
                container.appendChild(card);
                return { ...item, id };
            });
        }

        function updateDisplay() {
            const now = new Date(Date.now() + state.serverOffset);
            document.getElementById('current-time').textContent = now.toTimeString().split(' ')[0];

            const nextSec = Math.max(0, Math.ceil((state.nextUpdateTimestamp - Date.now()) / 1000));
            document.getElementById('update-countdown').textContent = document.hidden ? "PAUSED" : `NEXT: ${nextSec}S`;

            let needsReorder = false;
            state.timerData.forEach(item => {
                if (item.isFinished) return;
                const diff = item.targetDate - now;

                if (diff <= 0) {
                    item.isFinished = true;
                    const card = document.getElementById(`card-${item.id}`);
                    if (item.type === "start") {
                        card.classList.add('hidden');
                        setTimeout(() => { card.remove(); state.timerData = state.timerData.filter(t => t.id !== item.id); }, 600);
                    } else {
                        card.classList.add('finished');
                        document.getElementById(item.id).textContent = "00:00:00";
                        needsReorder = true;
                    }
                } else {
                    const s = Math.ceil(diff / 1000);
                    document.getElementById(item.id).textContent = [Math.floor(s/3600), Math.floor((s%3600)/60), s%60].map(v => String(v).padStart(2,'0')).join(':');
                }
            });
            if (needsReorder) reorderCards();
        }

        function reorderCards() {
            const container = document.getElementById('timer-container');
            if (!container) return;
            [...container.children]
                .sort((a, b) => a.classList.contains('finished') - b.classList.contains('finished'))
                .forEach(c => container.appendChild(c));
        }

        async function syncServerTime() {
            try {
                const res = await fetch('https://timeapi.io/api/Time/current/zone?timeZone=Asia/Tokyo');
                const data = await res.json();
                state.serverOffset = new Date(data.dateTime).getTime() - Date.now();
            } catch (e) { state.serverOffset = 0; }
        }

        async function watchUpdate() {
            if (document.hidden) {
                scheduleNext();
                return;
            }

            // ÂêåÊôÇ„É™„ÇØ„Ç®„Çπ„ÉàÂõûÈÅø„ÅÆ„É©„É≥„ÉÄ„É†ÈÅÖÂª∂
            await new Promise(r => setTimeout(r, Math.random() * 1500));

            const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${encodeURIComponent(CONFIG.CHECK_RANGE)}?key=${CONFIG.API_KEY}`;
            try {
                const res = await fetch(url);
                if (res.status === 429) {
                    updateStatus('rate limit', true);
                } else if (res.ok) {
                    const data = await res.json();
                    const currentDataStr = JSON.stringify(data.values);
                    if (currentDataStr !== state.lastCheckData) {
                        state.lastCheckData = currentDataStr;
                        await fetchSheetData();
                    } else {
                        const el = document.getElementById('status-area');
                        if (el && el.classList.contains('status-error')) {
                            el.classList.remove('status-error');
                            updateStatus('waiting');
                        }
                    }
                }
            } catch (e) {
                console.warn("API temporarily unavailable");
            }
            scheduleNext();
        }

        function scheduleNext() {
            state.nextUpdateTimestamp = Date.now() + CONFIG.POLL_INTERVAL;
            setTimeout(watchUpdate, CONFIG.POLL_INTERVAL);
        }

        function toggleTheme() {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            const theme = isDark ? 'light' : 'dark';
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            document.getElementById('theme-btn').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        async function init() {
            const theme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', theme);
            document.getElementById('theme-btn').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            await syncServerTime();
            await fetchSheetData();
            
            state.nextUpdateTimestamp = Date.now() + CONFIG.POLL_INTERVAL;
            setInterval(updateDisplay, 100);
            setTimeout(watchUpdate, CONFIG.POLL_INTERVAL);
        }

        init();
    </script>
</body>
</html>
